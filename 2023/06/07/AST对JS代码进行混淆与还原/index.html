<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AST对JS代码进行混淆与还原 | cthousand</title>
  <meta name="keywords" content=" javascript , AST ">
  <meta name="description" content="AST对JS代码进行混淆与还原 | cthousand">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="[TOC] 一、前言在js逆向中补环境这个方向一般是根据网站定制，即所谓的缺什么补什么，但网站补多了就会发现其实很多环境可以通用，如能将这部分抽离以复用，可以减少很大一部分逆向工作。 基于此，本文以window对象为例，参照浏览器端window对象，在本地node环境实现模仿，主要做了以下几点工作：  window原型继承关系梳理 window及其原型属性补充 实现一键脱环境脚本  二、思路在js">
<meta property="og:type" content="article">
<meta property="og:title" content="补环境之补window对象">
<meta property="og:url" content="http://example.com/2023/07/09/%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%A1%A5window%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="cthousand">
<meta property="og:description" content="[TOC] 一、前言在js逆向中补环境这个方向一般是根据网站定制，即所谓的缺什么补什么，但网站补多了就会发现其实很多环境可以通用，如能将这部分抽离以复用，可以减少很大一部分逆向工作。 基于此，本文以window对象为例，参照浏览器端window对象，在本地node环境实现模仿，主要做了以下几点工作：  window原型继承关系梳理 window及其原型属性补充 实现一键脱环境脚本  二、思路在js">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/82a7ffefec4244f6b44cf1c1193766e9.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/5a46d98421db44789eb34f23e65f9e24.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/ce8e1c4c15db445c8dc2d0a65060c22f.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/43f2a602abd2407bbce89a21ac01ff1e.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/c9fdef905359425cafec81edd1ab36f6.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/521035fe51ea4e1fa2614feff65c8066.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/74a5b132d8944d1e98aac4dec0b2b438.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/c253dd015deb4f3fa9352a12056f9704.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/18f3601df97846a89da3f9d56e86ddc4.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/9b7353634e304f7c8b1632a6456ed3be.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/63241fa682d54317af3a0d21064cc9fe.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/f5c92e43997e404abb9b54f31990d75c.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/d9f0bd78e8e542b185595ed173a0e224.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="og:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230710/0156aa9bf02345bfb04406c88f6337b8.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">
<meta property="article:published_time" content="2023-07-08T16:01:55.000Z">
<meta property="article:modified_time" content="2023-07-12T09:53:41.876Z">
<meta property="article:author" content="Cthousand">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="补环境">
<meta property="article:tag" content="理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230709/82a7ffefec4244f6b44cf1c1193766e9.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/darcula.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Cthousand</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/Cthousand"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:2454612285@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2454612285&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(11)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="开发">
                        
                        开发
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="爬虫">
                        
                        爬虫
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="11">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>阿里系</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>补环境</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>谷歌插件</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>加速乐</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>理论</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>AST</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>flask</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hook</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>javascript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>python</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>rpc</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>scrapy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>web逆向</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>web爬虫</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/07/09/%E8%A1%A5%E7%8E%AF%E5%A2%83%E4%B9%8B%E8%A1%A5window%E5%AF%B9%E8%B1%A1/"
           data-tag="javascript,补环境,理论"
           data-author="" >
            <span class="post-title" title="补环境之补window对象">补环境之补window对象</span>
            <span class="post-date" title="2023-07-09 00:01:55">2023/07/09</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/07/06/proxy%E4%B8%8Ereflect%E5%97%85%E6%8E%A2%E7%BC%BA%E5%A4%B1%E7%8E%AF%E5%A2%83/"
           data-tag="补环境"
           data-author="" >
            <span class="post-title" title="Proxy与Reflect嗅探缺失环境">Proxy与Reflect嗅探缺失环境</span>
            <span class="post-date" title="2023-07-06 11:03:49">2023/07/06</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/06/23/document-cookie%E7%9A%84hook%E5%8F%8A%E5%BC%95%E7%94%B3/"
           data-tag="javascript,hook"
           data-author="" >
            <span class="post-title" title="document.cookie的hook及引申">document.cookie的hook及引申</span>
            <span class="post-date" title="2023-06-23 16:26:03">2023/06/23</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/06/20/hook%E4%B8%8E%E5%8F%8Dhook%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%8A%97/"
           data-tag="hook"
           data-author="" >
            <span class="post-title" title="js逆向中hook与反hook之间的对抗">js逆向中hook与反hook之间的对抗</span>
            <span class="post-date" title="2023-06-20 15:46:05">2023/06/20</span>
        </a>
        
        
        <a  class="全部文章 开发 "
           href="/2023/06/18/%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E5%B1%8F%E8%94%BD%E7%99%BE%E5%BA%A6%E5%B9%BF%E5%91%8A/"
           data-tag="javascript,谷歌插件"
           data-author="" >
            <span class="post-title" title="谷歌插件屏蔽百度广告">谷歌插件屏蔽百度广告</span>
            <span class="post-date" title="2023-06-18 18:22:08">2023/06/18</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/06/18/%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E7%BB%95%E8%BF%87cookie%E5%8F%8D%E7%88%AC-%E5%A2%83%E5%A4%96%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/"
           data-tag="web爬虫,python,javascript,谷歌插件,flask"
           data-author="" >
            <span class="post-title" title="谷歌插件绕过cookie反爬_某境外电商网站">谷歌插件绕过cookie反爬_某境外电商网站</span>
            <span class="post-date" title="2023-06-18 15:54:04">2023/06/18</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/06/13/RPC%E8%BF%87%E6%9F%90%E4%B9%8Ezse96%E5%8F%82%E6%95%B0-%E6%9F%90%E4%B9%8E%E7%83%AD%E6%90%9C/"
           data-tag="web爬虫,rpc,python,javascript"
           data-author="" >
            <span class="post-title" title="RPC过某乎zse96参数-某乎热搜">RPC过某乎zse96参数-某乎热搜</span>
            <span class="post-date" title="2023-06-13 14:22:36">2023/06/13</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/06/07/AST%E5%AF%B9JS%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E6%B7%B7%E6%B7%86%E4%B8%8E%E8%BF%98%E5%8E%9F/"
           data-tag="javascript,AST"
           data-author="" >
            <span class="post-title" title="AST对JS代码进行混淆与还原">AST对JS代码进行混淆与还原</span>
            <span class="post-date" title="2023-06-07 00:48:10">2023/06/07</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/05/18/%E7%BA%AF%E6%89%A3%E8%BF%87%E9%98%BF%E9%87%8C%E7%B3%BBsign%E5%8F%82%E6%95%B0-%E6%9F%90%E5%AE%9D%E6%B3%95%E6%8B%8D%E7%BD%91/"
           data-tag="python,javascript,web逆向,阿里系"
           data-author="" >
            <span class="post-title" title="纯扣过阿里系sign参数-某宝法拍网.md">纯扣过阿里系sign参数-某宝法拍网.md</span>
            <span class="post-date" title="2023-05-18 16:34:23">2023/05/18</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/05/17/%E7%BA%AF%E6%89%A3%E8%BF%87%E5%8A%A0%E9%80%9F%E4%B9%90-%E6%9F%90%E4%BF%A1%E7%94%A8%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99/"
           data-tag="web爬虫,python,javascript,加速乐"
           data-author="" >
            <span class="post-title" title="纯扣过加速乐-某信用查询网站">纯扣过加速乐-某信用查询网站</span>
            <span class="post-date" title="2023-05-17 13:50:48">2023/05/17</span>
        </a>
        
        
        <a  class="全部文章 爬虫 "
           href="/2023/05/16/scrapy%E6%89%B9%E9%87%8F%E9%87%87%E9%9B%86-%E6%9F%90%E5%95%86%E5%A4%A7%E6%95%B0%E6%8D%AE/"
           data-tag="web爬虫,python,javascript,scrapy"
           data-author="" >
            <span class="post-title" title="scrapy批量采集-某商大数据">scrapy批量采集-某商大数据</span>
            <span class="post-date" title="2023-05-16 16:34:23">2023/05/16</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-AST对JS代码进行混淆与还原" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">AST对JS代码进行混淆与还原</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="爬虫">爬虫</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">javascript</a>
            
            <a class="color4">AST</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2023-06-19 04:52:55'>2023-06-07 00:48</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AST%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">AST基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B7%B7%E6%B7%86"><span class="toc-text">JS代码的混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%89%8D%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">混淆前的预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">改变对象访问方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86"><span class="toc-text">内置对象处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B7%B7%E6%B7%86"><span class="toc-text">常量与标识符混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-text">字符串常量处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86"><span class="toc-text">字符串加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D"><span class="toc-text">大数组分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F"><span class="toc-text">数组乱序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E6%B5%8B"><span class="toc-text">格式化检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%88%86%E7%A0%B4"><span class="toc-text">内存爆破</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%B8%B8%E9%87%8F%E5%8A%A0%E5%AF%86"><span class="toc-text">数值常量加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B7%B7%E6%B7%86"><span class="toc-text">标识符混淆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B7%B7%E6%B7%86"><span class="toc-text">代码块混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E8%BD%AC%E5%87%BD%E6%95%B0%E8%8A%B1%E6%8C%87%E4%BB%A4"><span class="toc-text">二项式转函数花指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E8%A1%8C%E5%8A%A0%E5%AF%86"><span class="toc-text">指定代码行加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ascii%E7%A0%81%E5%8A%A0%E5%AF%86"><span class="toc-text">ascii码加密</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%E7%9A%84%E6%B7%B7%E6%B7%86"><span class="toc-text">执行逻辑的混淆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%B9%B3%E5%9D%A6%E5%8C%96"><span class="toc-text">流程平坦化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8E%8B%E7%BC%A9"><span class="toc-text">逗号表达式压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JS%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%98%E5%8E%9F"><span class="toc-text">JS代码的还原</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81"><span class="toc-text">分析混淆代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BF%98%E5%8E%9F"><span class="toc-text">数值还原</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%98%E5%8E%9F"><span class="toc-text">字符串还原</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%98%E5%8E%9F"><span class="toc-text">逗号表达式还原</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%81%9A%E6%A1%88%E4%BE%8B%E7%9A%84JS%E4%BB%A3%E7%A0%81"><span class="toc-text">用于做案例的JS代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">用于还原数组乱序的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%B7%B7%E6%B7%86JS%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">用于混淆JS的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%B7%B7JS%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">用于解混JS的代码</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AST基本概念"><a href="#AST基本概念" class="headerlink" title="AST基本概念"></a>AST基本概念</h1><p>中文名为<code>抽象语法树</code>，英文名称：<code>Abstract Syntax Code</code>，是源代码语法结构的一种抽象表示方式，具有明显的树状结构特征，原本紧密联系、结构紧凑的代码被切分成了不可再分的零碎词块，且语法不会表示出真实语法中的所有细节，因此带来了”抽象”的感觉。例如，编写一个简单的1+1&#x3D;&#x3D;2，表达式在解析后得到AST抽象语法树如下所示。</p>
<pre><code class="json">&#123;
  &quot;type&quot;: &quot;Program&quot;,
  &quot;start&quot;: 0,
  &quot;end&quot;: 6,
  &quot;body&quot;: [
    &#123;
      &quot;type&quot;: &quot;ExpressionStatement&quot;,
      &quot;start&quot;: 0,
      &quot;end&quot;: 6,
      &quot;expression&quot;: &#123;
        &quot;type&quot;: &quot;BinaryExpression&quot;,
        &quot;start&quot;: 0,
        &quot;end&quot;: 6,
        &quot;left&quot;: &#123;
          &quot;type&quot;: &quot;BinaryExpression&quot;,
          &quot;start&quot;: 0,
          &quot;end&quot;: 3,
          &quot;left&quot;: &#123;
            &quot;type&quot;: &quot;Literal&quot;,
            &quot;start&quot;: 0,
            &quot;end&quot;: 1,
            &quot;value&quot;: 1,
            &quot;raw&quot;: &quot;1&quot;
          &#125;,
          &quot;operator&quot;: &quot;+&quot;,
          &quot;right&quot;: &#123;
            &quot;type&quot;: &quot;Literal&quot;,
            &quot;start&quot;: 2,
            &quot;end&quot;: 3,
            &quot;value&quot;: 1,
            &quot;raw&quot;: &quot;1&quot;
          &#125;
        &#125;,
        &quot;operator&quot;: &quot;==&quot;,
        &quot;right&quot;: &#123;
          &quot;type&quot;: &quot;Literal&quot;,
          &quot;start&quot;: 5,
          &quot;end&quot;: 6,
          &quot;value&quot;: 2,
          &quot;raw&quot;: &quot;2&quot;
        &#125;
      &#125;
    &#125;
  ],
  &quot;sourceType&quot;: &quot;module&quot;
&#125;
</code></pre>
<p>其实，任何编程语言都需要一些软件来将源代码处理AST形式的数据结构以便让计算机能够理解，对于JS而言，可以使用Babel作为编译器将JS代码解构成AST。<br><a target="_blank" rel="noopener" href="https://www.astexplorer.net/">AST在线编译</a></p>
<h1 id="JS代码的混淆"><a href="#JS代码的混淆" class="headerlink" title="JS代码的混淆"></a>JS代码的混淆</h1><p>JS代码如果不混淆，那么数据对于逆向者而言就如同探囊取物，下面对常见的混淆方式分别进行描述。大致可以分为三类，第一类是常量与标示符的混淆；第二类是代码块的混淆；第三类是执行逻辑的混淆。<br><br>以下面这段js代码为例，进行混淆处理。</p>
<pre><code class="javascript">Date.prototype.format = function (formatStr) &#123;
    var str = formatStr;
    str = str.replace(/yyyy|YYYY/, this.getFullYear());
    str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : &#39;0&#39; + (this.getMonth() + 1));
    str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#39;0&#39; + this.getDate()); //AsciiEncrypt
    return str;
&#125;
console.log(new Date().format(&#39;yyyy-MM-dd&#39;));
</code></pre>
<p>这段代码是在Date的原型链上新增一个实例方法，功能是以指定格式输出当前的日期，浏览器控制台执行结果如下。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/95088a97a346460497caa763a7006fa4.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="执行结果"></p>
<h2 id="混淆前的预处理"><a href="#混淆前的预处理" class="headerlink" title="混淆前的预处理"></a>混淆前的预处理</h2><p>在脚本文件中提前导入相关的依赖包，将混淆方案的相关实现封装成类，后续的混淆步骤都挂在这个类的原型链上。</p>
<pre><code class="javascript">const parser = require(&#39;@babel/parser&#39;) //解析
const traverse = require(&#39;@babel/traverse&#39;).default //遍历
const t = require(&#39;@babel/types&#39;) //类型判定与生成
const generator = require(&#39;@babel/generator&#39;).default //ast转code
const fs = require(&#39;fs&#39;) //文件读写

//把混淆方案的相关实现封装成类
function ConfoundUtils(ast, encryptFunc) &#123;
    this.ast = ast;
    this.bigArr = [];
    //接收传进来的函数，用于字符串加密
    this.encryptFunc = encryptFunc;
&#125;
</code></pre>
<h3 id="改变对象访问方式"><a href="#改变对象访问方式" class="headerlink" title="改变对象访问方式"></a>改变对象访问方式</h3><p>举例说明，也就是将<code>console.log</code>转成<code>console[&#39;log&#39;]</code>形式，目的是为了方便进行大数组分配、字符串加密等。</p>
<pre><code class="javascript">ConfoundUtils.prototype.changeAccessMode = function () &#123;
    traverse(this.ast, &#123;
        MemberExpression(path) &#123; //遍历所有的成员表达式
            if (t.isIdentifier(path.node.property)) &#123; //如果节点的属性是标识符的话
                let name = path.node.property.name; //获取标识符的名称
                path.node.property = t.stringLiteral(name); //用字符串字面量替换原先的标识符
                path.node.computed = true; //对象读写属性设置为true
            &#125;
        &#125;
    &#125;)
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/f00558762763432082f92dcc5549d65c.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<h3 id="内置对象处理"><a href="#内置对象处理" class="headerlink" title="内置对象处理"></a>内置对象处理</h3><p>某些内置对象如<code>Date</code>,本来是标识符性质，可以转为<code>window.[&#39;Date&#39;]</code></p>
<pre><code class="javascript">ConfoundUtils.prototype.changeBuiltinObjects = function () &#123;
    traverse(this.ast, &#123;
        Identifier(path) &#123;
            let name = path.node.name; //获取标识符的名称
            //如果名称与这些内置对象同名
            if (&#39;eval|parseInt|encodeURIComponent|Object|Function|Boolean|Number|Math|Date|String|RegExp|Array&#39;.indexOf(name) !== -1) &#123;
                //用window[name]成员表达式替换之
                path.replaceWith(t.MemberExpression(t.identifier(&#39;window&#39;), t.stringLiteral(name), true));
            &#125;
        &#125;
    &#125;)
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/a5cbc82dd057493bbdcedee52cf015cb.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<h2 id="常量与标识符混淆"><a href="#常量与标识符混淆" class="headerlink" title="常量与标识符混淆"></a>常量与标识符混淆</h2><p>常量一般是字符串或者数值，在上一步中已经通过改变对象属性访问方式产生了很多字符串，这些都可以混淆。</p>
<h3 id="字符串常量处理"><a href="#字符串常量处理" class="headerlink" title="字符串常量处理"></a>字符串常量处理</h3><h4 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h4><p>对全文中出现的字符串进行加密，加密方法可以是自带的base64也可自定义加密方法。</p>
<h4 id="大数组分配"><a href="#大数组分配" class="headerlink" title="大数组分配"></a>大数组分配</h4><p>将加密后的字符串放入数组中统一分配，通过下标取值，当数组很大时，很容易让逆向者失去耐心，一般大数组和字符串加密同时处理。</p>
<pre><code class="javascript">ConfoundUtils.prototype.arrayConfound = function () &#123;
    let bigArr = [];
    let encryptFunc = this.encryptFunc;
    traverse(this.ast, &#123;
        StringLiteral(path) &#123;
            let cipherText = encryptFunc(path.node.value); //获取字符串值
            let bigArrIndex = bigArr.indexOf(cipherText); //在大数组中查找是否有这个值,如有返回索引
            let index = bigArrIndex; // 索引赋值给index
            if (bigArrIndex === -1) &#123; //若索引不存在
                let length = bigArr.push(cipherText); //将字符串推入大数组,并返回数组长度,push是推入最后
                index = length - 1 //index为大数组中最后一位的索引
            &#125;
            //构造函数调用表达式(加密),内部成员表达式(数组混淆),从数组中用索引取值
            let encStr = t.callExpression(t.identifier(&#39;atob&#39;),
                [t.memberExpression(t.identifier(&#39;arr&#39;), t.numericLiteral(index), true)]);
            path.replaceWith(encStr);
        &#125;
    &#125;);
    bigArr = bigArr.map(function (v) &#123;
        return t.StringLiteral(v); //大数组内的成员转ast代码
    &#125;);
    this.bigArr = bigArr; 
&#125;
//插入大数组
ConfoundUtils.prototype.unshiftArrayDeclaration = function () &#123;
    this.bigArr = t.variableDeclarator(t.identifier(&#39;arr&#39;), t.arrayExpression(this.bigArr)); //构建大数组变量
    this.bigArr = t.variableDeclaration(&#39;var&#39;, [this.bigArr]); //构建大数组变量声明语句
    this.ast.program.body.unshift(this.bigArr); //在ast的最上层插入大数组
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/52735e611a014cd89863f43104be96a5.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<h4 id="数组乱序"><a href="#数组乱序" class="headerlink" title="数组乱序"></a>数组乱序</h4><p>通过将大数组打乱放置，后面插入一个自执行函数用于还原顺序，由于还原函数中的<code>push</code>和<code>shift</code>字符串含义比较明显，可以考虑用16进制编码表示，如此，逆向者必须找到还原函数，而还原函数中还可以埋坑进去，如格式化检测加内存爆破。</p>
<pre><code class="JAVASCRIPT">//现在外部新建一个astFront.js用于存放还原函数
!(function (myArr, num) &#123;
    var outOrder = function (num) &#123;
        while (--num) &#123; //循环次数递减
            myArr.push(myArr.shift()); //数组开头取出末尾插入
        &#125;
    &#125;;

&#125;)(arr, 0x10) //0x10表示移动16位，用16进制表示增加迷惑性
//对还原函数进行16进制处理
ConfoundUtils.prototype.stringToHex = function () &#123;
    function hexEnc(code) &#123;
        for (var hexStr = &#39;&#39;, i = 0, s; i &lt; code.length; i++) &#123;
            s = code.charCodeAt(i).toString(16); 
            hexStr += &#39;\\x&#39; + s;
        &#125;
        return hexStr
    &#125;

    traverse(this.ast, &#123;
        MemberExpression(path) &#123; //遍历成员表达式
            if (t.isIdentifier(path.node.property)) &#123; //判断节点的属性是不是标识符，因为也有可能是字符串
                let name = path.node.property.name; //取出主体名
                //16进制替换
                path.node.property = t.stringLiteral(hexEnc(name));
                path.node.computed = true;//16进制也是支持用.属性的形式访问的
            &#125;
        &#125;
    &#125;)
&#125;
//把还原ast放到混淆ast的上面,主要注意的是这一步要放在大数组放置步骤的前面
ConfoundUtils.prototype.astConcatUnshift = function (ast) &#123;
    this.ast.program.body.unshift(ast)
&#125;
//混淆的代码中，如果有十六进制字符串加密，ast转成代码后会有多余的转义字符，需要替换掉
    code = code.replace(/\\\\x/g, &#39;\\x&#39;)
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/804d4519a2dd4373819e493859a7de9e.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<p>此时，数组提取中的数字就不再与大数组中一一对应。</p>
<h5 id="格式化检测"><a href="#格式化检测" class="headerlink" title="格式化检测"></a>格式化检测</h5><p>浏览器中的网站js代码正常是压缩的状态，而逆向者在沙盒环境中执行往往是格式化状态，利用这点，在自执行函数中对某个函数利用正则校验其是否被格式化，如果被格式化，可以选择执行错误的流程分支，进入内存爆破的函数，让浏览器陷入崩溃。</p>
<h5 id="内存爆破"><a href="#内存爆破" class="headerlink" title="内存爆破"></a>内存爆破</h5><p>当检测到当前环境不正常时执行，利用while或者for循环等，执行一个永不会结束的代码，这会持续消耗浏览器内存，直到浏览器崩溃。</p>
<pre><code class="javascript">//在之前定义好的astFront代码中做补充
!(function (myArr, num) &#123;
    var outOrder = function (num) &#123;
        while (--num) &#123; //循环次数递减
            myArr.push(myArr.shift()); //数组开头取出末尾插入
        &#125;
    &#125;;
    //内存爆破
    var memBreak = function () &#123;
        for (var i = 0, j = [1]; i &lt; j.length; i++) &#123;
            j.push(i) //每次都push,逻辑上i永远都小于j.length
        &#125;
    &#125;

    var formatFuc = function () &#123;
        return &#39;debug review&#39;
    &#125;
    var formatReg = /[\r\n]/; //查找换行符或回车符

    var match = formatReg.exec(formatFuc.toString()); //格式化检测
    if (match) &#123;
        memBreak(); //如果检测出来格式化就进入内存爆破的函数
    &#125; else &#123;
        outOrder(num); //否则执行正确的逻辑分支
    &#125;
&#125;)(arr, 0x10) //0x10表示移动16位，用16进制表示增加迷惑性
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/5ac859cda38046cc90e9fbe5380d6b7f.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="如果检测到特定的代码被格式化"><br><br><br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/afb80ea05a3748538600ce87c944876a.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="如果代码未被格式化"></p>
<h3 id="数值常量加密"><a href="#数值常量加密" class="headerlink" title="数值常量加密"></a>数值常量加密</h3><p>一些数值,例如大数组的下标取值,可以利用异或操作增加复杂度,例如1,可以变成123457 ^ 123456表示。</p>
<pre><code class="javascript">ConfoundUtils.prototype.numericEncrypt = function () &#123;
    traverse(this.ast, &#123;
        NumericLiteral(path) &#123;
            let value = path.node.value; //获取数值常量的值
            //生成100000~999999的随机10进制的字符串
            let key = parseInt(Math.random() * (999999 - 100000) + 100000, 10);
            let cipherNum = value ^ key;//真实数值异或这个随机值得到一个加密值,异或是两边二进制对位同为0,异为1
            //那么加密异或key也一定可以还原为真实值
            path.replaceWith(t.binaryExpression(&#39;^&#39;, t.numericLiteral(cipherNum), t.numericLiteral(key)));
            path.skip(); //这是因为替换后防止继续深度遍历numericLiteral,形成死循环
        &#125;
    &#125;)
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/bef650ca631b4cd38ae8e5606d773aa7.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<h3 id="标识符混淆"><a href="#标识符混淆" class="headerlink" title="标识符混淆"></a>标识符混淆</h3><p>标识符名称在开发时往往定义成具有语义的名称，而这为逆向者提供了猜测代码逻辑的便利，通过将所有名称改成无意义的名称，使逆向者无法看词猜意。</p>
<p><strong>随机生成办法</strong>：每个参数都有自己的作用域，因此每个不同作用域的标识符可以重名，这样逆向者搜索某个标识符的搜索结果就会变多，逆向者无法快速定位，此外，推荐使用oO0等高度相识的符号构成标识符名称，进一步增加混淆程度。</p>
<pre><code class="javascript">ConfoundUtils.prototype.renameIdentifier = function () &#123;
    //标识符混淆之前先转成代码再解析，确保新生成的一些节点被解析到，因为type生成的节点并不会自动携带path，所以无法被遍历到
    let code = generator(this.ast).code;
    let newAst = parser.parse(code);

    //生成标识符
    function generatorIdentifier(decNum) &#123;
        let arr = [&#39;0&#39;, &#39;o&#39;, &#39;O&#39;]; //这3个字符长得比较像，用来替换3进制中012
        let retval = [];
        //十进制转三进制的算法
        while (decNum &gt; 0) &#123;
            retval.push(decNum % 3);
            decNum = parseInt(decNum / 3);
        &#125;
        //除余法需要先事先翻转一下
        let Identifier = retval.reverse().map(function (v) &#123;
            return arr[v]
        &#125;).join(&#39;&#39;)
        //不足6位就补，开头是0也补(数字不可做标识符的开头)
        Identifier.length &lt; 6 ? (Identifier = (&#39;OOOOOO&#39; + Identifier).substring(-6)) : Identifier[0] === &#39;0&#39; &amp;&amp; (Identifier = &#39;O&#39; + Identifier);
        return Identifier
    &#125;

    function renameOwnBinding(path) &#123;
        let OwnBindingObj = &#123;&#125;, globalBindingObj = &#123;&#125;, i = 0; //从十进制的0开始
        path.traverse(&#123;
            Identifier(p) &#123;
                let name = p.node.name; //取出标识符的名称
                let binding = p.scope.getOwnBinding(name); //拿到这个标识符在当前作用域的节点绑定，就是说在当前作用域中定义的
                binding &amp;&amp; generator(binding.scope.block).code === path + &#39;&#39; ?
                    (OwnBindingObj[name] = binding) : (globalBindingObj[name] = 1); //将局部标识符和全局标识符区分开
            &#125;
        &#125;)
        for (let oldName in OwnBindingObj) &#123; //对于每一个局部作用域中的成员
            do &#123;
                var newName = generatorIdentifier(i++);
            &#125; while (globalBindingObj[newName]); //为了不与全局变量重名，虽然这种可能性比较小
            OwnBindingObj[oldName].scope.rename(oldName, newName); //利用scope.rename对所有引用的变量批量修改
        &#125;
    &#125;

    traverse(newAst, &#123;
        &#39;Program|FunctionExpression|FunctionDeclaration&#39;(path) &#123;
            renameOwnBinding(path); //无论是全局还是匿名函数内还是函数声明内都查找标识符并改名
        &#125;
    &#125;)
    this.ast = newAst; //把新ast重新赋值给this.ast
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/7a509d2ceecb45aaab2d1ce2bdda140e.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<p>至此第一部分完成，相较于原先代码，阅读难度显著增加。</p>
<h2 id="代码块混淆"><a href="#代码块混淆" class="headerlink" title="代码块混淆"></a>代码块混淆</h2><p>代码块一般指的是函数体内部代码，可以是匿名函数，也可以是函数表达式，通过可以用来混淆的操作有花指令膨胀、逗号表达式压缩、指定代码行加密等。为了增强前后的对比效果，第一部分的混淆不启用。</p>
<h3 id="二项式转函数花指令"><a href="#二项式转函数花指令" class="headerlink" title="二项式转函数花指令"></a>二项式转函数花指令</h3><p>诸如<code>a+b</code>,可以用<code>function x(a,b)&#123;return a+b&#125;</code>表示,利用函数调用的形式来表达，能够起到一行变十行的混淆效果。</p>
<pre><code class="javascript">ConfoundUtils.prototype.binaryToFunc = function () &#123;
    traverse(this.ast, &#123;
        BinaryExpression(path) &#123; //遍历所有的二项式表达式节点
            let operator = path.node.operator;//获取节点中的操作符
            let left = path.node.left; //获取左边内容
            let right = path.node.right; //获取右边内容
            let a = t.identifier(&#39;a&#39;); //新建标示符a
            let b = t.identifier(&#39;b&#39;); //新建标示符b
            //生成唯一性的随机标示符作为函数名称，由于后期标识符会统一修改，这个仅做中转
            let funcNameIdentifier = path.scope.generateUidIdentifier(&#39;xxx&#39;);
            // 定义一个函数声明语句
            let func = t.functionDeclaration(
                funcNameIdentifier,
                [a, b],
                t.blockStatement([t.returnStatement(
                    t.binaryExpression(operator, a, b)
                )]));
            // 寻找当前最近的函数体表达式节点，这里用findParent
            let BlockStatement = path.findParent(
                function (p) &#123;
                    return p.isBlockStatement()
                &#125;
            );
            // 开头插入花指令函数
            BlockStatement.node.body.unshift(func);
            // 节点替换成函数调用表达式
            path.replaceWith(t.callExpression(funcNameIdentifier, [left, right]));
        &#125;
    &#125;)
&#125;  
</code></pre>
<p>效果</p>
<pre><code class="javascript">Date.prototype.format = function (formatStr) &#123;
  function _xxx7(a, b) &#123;
    return a + b;
  &#125;
  function _xxx6(a, b) &#123;
    return a &gt; b;
  &#125;
  function _xxx5(a, b) &#123;
    return a + b;
  &#125;
  function _xxx4(a, b) &#123;
    return a + b;
  &#125;
  function _xxx3(a, b) &#123;
    return a + b;
  &#125;
  function _xxx2(a, b) &#123;
    return a + b;
  &#125;
  function _xxx(a, b) &#123;
    return a &gt; b;
  &#125;
  var str = formatStr;
  str = str.replace(/yyyy|YYYY/, this.getFullYear());
  str = str.replace(/MM/, _xxx(_xxx2(this.getMonth(), 1), 9) ? _xxx3(this.getMonth(), 1).toString() : _xxx4(&#39;0&#39;, _xxx5(this.getMonth(), 1)));
  str = str.replace(/dd|DD/, _xxx6(this.getDate(), 9) ? this.getDate().toString() : _xxx7(&#39;0&#39;, this.getDate()));
  return str;
&#125;;
console.log(new Date().format(&#39;yyyy-MM-dd&#39;));
</code></pre>
<p>可以看到很多本来是<code>+-&lt;&gt;</code>等简单的二项式运算都独立成了函数调用，代码行数也显著上去，后期再配合上标识符混淆，可阅读性将显著降低。</p>
<h3 id="指定代码行加密"><a href="#指定代码行加密" class="headerlink" title="指定代码行加密"></a>指定代码行加密</h3><p>一般用于对核心代码行单独加密，例如base64和ascii码加密，也可以是自定义加密方式。</p>
<h4 id="ascii码加密"><a href="#ascii码加密" class="headerlink" title="ascii码加密"></a>ascii码加密</h4><p>在待混淆的js文件指定行注明想要加密方式，这里用<code>AsciiEncrypt</code>,原理是ast识别到指定注释行后，对该行代码用ascii码加密然后转字符串，再利用eval特性在vm中执行代码。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/38c12443e48a47959f961d656584afb2.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="加密行注释"></p>
<pre><code class="javascript">ConfoundUtils.prototype.appointedCodeLineAscii = function () &#123;
    traverse(this.ast, &#123;
        FunctionExpression(path) &#123; //遍历所有函数表达式
            let blockStatement = path.node.body; //提取出函数体
            let Statements = blockStatement.body.map(function (v) &#123; //遍历函数体中每一行
                if (t.isReturnStatement(v)) return v; //如果是返回语句则不修改
                //如果没有注释部分且注释部分非ASCIIEncrypt则不修改
                if (!(v.trailingComments &amp;&amp; v.trailingComments[0].value === &#39;ASCIIEncrypt&#39;)) return v;
                //删除注释部分
                delete v.trailingComments;
                let code = generator(v).code; //将函数转化为code
                let codeAscii = [].map.call(code, function (v) &#123;
                    return t.numericLiteral(v.charCodeAt(0)); //把字符串中每个字符串转化成ascii码形式变成一个列表
                &#125;);
                // 定义一个成员表达式，对象是String,成员是fromCharCode
                let decryptFunctionName = t.memberExpression(t.identifier(&#39;String&#39;), t.identifier(&#39;fromCharCode&#39;));
                //定义一个函数调用，函数是上面那个成员表达式，参数是ascii化的代码行
                let decryptFunc = t.callExpression(decryptFunctionName, codeAscii)
                //返回一个表达式，内嵌函数调用，调用方是eval，参数是fromCharCode解ascii码后的字符串,eval执行的代码会在eval里运行
                return t.expressionStatement(t.callExpression(t.identifier(&#39;eval&#39;), [decryptFunc]))
            &#125;);
            //将当前func path的函数体替换掉
            path.get(&#39;body&#39;).replaceWith(t.blockStatement(Statements));
        &#125;
    &#125;)
&#125;  
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/9fa5d3386d984e14927f1e564e0437ef.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="效果"></p>
<h2 id="执行逻辑的混淆"><a href="#执行逻辑的混淆" class="headerlink" title="执行逻辑的混淆"></a>执行逻辑的混淆</h2><p>一般情况下，开发写代码逻辑是自上而下的，逆向者可以方便的一行一行阅读，此时可以通过流程平坦化打乱执行顺序，也可以通过逗号表达式将执行顺序变成从内到外。</p>
<h3 id="流程平坦化"><a href="#流程平坦化" class="headerlink" title="流程平坦化"></a>流程平坦化</h3><p>简单来说就是利用循环中<code>switch...case</code>配合一个规定了执行顺序的分发器执行，而这个分发器的执行顺序事前被随机成乱序。</p>
<pre><code class="javascript">ConfoundUtils.prototype.controlFlowFlat = function () &#123;
    traverse(this.ast, &#123;
        //遍历所有的函数表达式
        FunctionExpression(path) &#123;
            //取出函数体
            let blockStatement = path.node.body;
            let Statements = blockStatement.body.map(function (v, i) &#123;
                //将函数体列表的顺序和语句存储起来
                return &#123;index: i, value: v&#125;
            &#125;);
            //得到代码行的长度
            let i = Statements.length;
            //对代码行列表进行乱序处理，虽然乱序处理了，但真实序号依然与代码绑定在一起
            while (i) &#123;
                let j = Math.floor(Math.random() * i--);
                [Statements[j], Statements[i]] = [Statements[i], Statements[j]]
            &#125;
            //定义一个分发器
            let dispenserArr = [];
            //定义一个存在case块的列表
            let cases = [];
            //对代码行列表进行映射，篡改一些对象的引用关系
            Statements.map(function (v, i) &#123;
                //分发器记录真实顺序
                dispenserArr[v.index] = i;
                //构建swtich的case语句，包括一个判断条件，执行流程和一个continue语句
                let switchCase = t.switchCase(t.numericLiteral(i), [v.value, t.continueStatement()]);
                cases.push(switchCase)
            &#125;);
            //分发器数组用｜连接成字符串
            let dispenserStr = dispenserArr.join(&#39;|&#39;);
            //构建不重名的标识符代表分发器
            let array = path.scope.generateUidIdentifier(&#39;array&#39;);
            //构建不重名的标识符代表起始索引
            let index = path.scope.generateUidIdentifier(&#39;index&#39;);
            //构建成员表达式，obj是分发器字符串，成员是split
            let callee = t.memberExpression(t.stringLiteral(dispenserStr), t.identifier(&#39;split&#39;));
            //构建函数调用，传入参数&#39;|&#39;
            let arrayInit = t.callExpression(callee, [t.stringLiteral(&#39;|&#39;)]);
            //构建变量声明器，变量明是分发器标识符，初始化是上面那个
            let varArray = t.variableDeclarator(array, arrayInit);
            //构建初始索引，从0开始
            let varIndex = t.variableDeclarator(index, t.numericLiteral(0))
            //用let将上面2为构成完整的变量声明语句
            let dispenser = t.variableDeclaration(&#39;let&#39;, [varArray, varIndex]);
            //构建自增表达式
            let updExp = t.updateExpression(&#39;++&#39;, index);
            //构建成员表达式
            let memExp = t.memberExpression(array, updExp, true);
            //构建单项式表达式，这里用为了将字符串强转成字符串类型，因为case中用的是===全等，并不会自动转化类型
            let discriminent = t.unaryExpression(&#39;+&#39;, memExp);
            //将switch表达式和case块合成完整的switch语句块
            let switchSta = t.switchStatement(discriminent, cases);
            let unaExp = t.unaryExpression(&#39;!&#39;, t.arrayExpression());
            //!![]意思就是true，之所以不直接用当然是为了混淆视听
            unaExp = t.unaryExpression(&#39;!&#39;, unaExp);
            //构建while循环语句，需要循环条件和循环体，循环体需要一个switch块和一个break语句，因为需要保证到最后没有匹配时默认退出循环
            let whileSta = t.whileStatement(unaExp, t.blockStatement([switchSta, t.breakStatement()]));
            //将函数体节点替换成由分发器和while循环构成的函数体语句
            path.get(&#39;body&#39;).replaceWith(t.blockStatement([dispenser, whileSta]));
        &#125;
    &#125;)
&#125;
</code></pre>
<p>效果</p>
<pre><code class="javascript">Date.prototype.format = function (formatStr) &#123;
  let _array = &quot;3|1|0|2|4&quot;.split(&quot;|&quot;),
    _index = 0;
  while (!![]) &#123;
    switch (+_array[_index++]) &#123;
      case 0:
        str = str.replace(/MM/, this.getMonth() + 1 &gt; 9 ? (this.getMonth() + 1).toString() : &#39;0&#39; + (this.getMonth() + 1));
        continue;
      case 1:
        str = str.replace(/yyyy|YYYY/, this.getFullYear());
        continue;
      case 2:
        str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#39;0&#39; + this.getDate());
        continue;
      case 3:
        var str = formatStr;
        continue;
      case 4:
        return str;
        continue;
    &#125;
    break;
  &#125;
&#125;;
console.log(new Date().format(&#39;yyyy-MM-dd&#39;));  
</code></pre>
<p>可以看出该函数内部执行顺序已经不再是自上而下了，而是受一个分发器的控制<code>let _array = &quot;3|1|0|2|4&quot;.split(&quot;|&quot;)</code>，这显然是乱序的。</p>
<h3 id="逗号表达式压缩"><a href="#逗号表达式压缩" class="headerlink" title="逗号表达式压缩"></a>逗号表达式压缩</h3><p>如果平坦化是纵向打乱代码的话，那逗号表达式就是横向压缩代码，利用逗号表达式从左向右执行的特性，将多行代码置于一行内表达。</p>
<pre><code class="javascript">ConfoundUtils.prototype.toSequenceConfuse = function () &#123;
    //逗号表达式混淆
    traverse(this.ast, &#123;
        FunctionExpression(path) &#123;
            let blockStatement = path.node.body; //取出函数体
            let blockStatementLength = blockStatement.body.length; //得到函数体代码行数
            if (blockStatementLength &lt; 2) return; //如果小于2直接返回不处理
            path.traverse(&#123;
                VariableDeclaration(p) &#123; //遍历函数下的所有变量声明语句
                    let declarations = p.node.declarations; //得到声明体
                    let statements = [] //定义一个列表用于存放函数赋值表达式
                    declarations.map(function (v) &#123;
                        path.node.params.push(v.id); //对变量声明语句处理，把标识符提到参数里面
                        //如果有初始化赋值，就把赋予语句放到之前定义好的列表里面
                        v.init &amp;&amp; statements.push(t.assignmentExpression(&#39;=&#39;, v.id, v.init));
                    &#125;)
                    //把所有变量声明语句变成赋值语句
                    p.replaceInline(statements);
                &#125;
            &#125;)
            //处理赋值语句、返回语句和函数调用语句
            let firstSta = blockStatement.body[0], i = 1; //从第一行开始
            let secondSta; //定义第二行
            while (i &lt; blockStatementLength) &#123; //如果索引小于函数体的行数
                let tempSta = blockStatement.body[i++]; //i++先赋值再自增，暂存下一行
                t.isExpressionStatement(tempSta) ? //是否是表达式语句
                    secondSta = tempSta.expression : secondSta = tempSta; //是把里面的expreesion赋值给第二行，否则把本身赋值给第二行
                //处理返回语句
                if (t.isReturnStatement(secondSta)) &#123; //第二行是否为return 语句
                    firstSta = t.returnStatement( //如果是就用return 包裹第一行和第二行return语句的参数部分
                        t.toSequenceExpression([firstSta, secondSta.argument])
                    )
                &#125; else if (t.isAssignmentExpression(secondSta)) &#123; //如果第二行是赋值语句
                    if (t.isCallExpression(secondSta.right)) &#123; //是否赋值语句的右边是函数调用语句
                        let callee = secondSta.right.callee; //如果是就把函数调用obj提出来
                        callee.object = t.toSequenceExpression([firstSta, callee.object]); //和第一行语句组成逗号表达式
                        firstSta = secondSta; //赋值给第一行
                    &#125; else &#123;
                        secondSta.right = t.toSequenceExpression([firstSta, secondSta.right]); //否则拼接第一行和第二行的右边赋值部分给到第二行的右边
                        firstSta = secondSta; //再把第二行赋值给第一行
                    &#125;
                &#125; else &#123;
                    firstSta = t.toSequenceExpression([firstSta, secondSta]); //如果既不是返回语句也非赋值语句，就简单的拼成逗号表达式
                &#125;
            &#125;
            if (t.isReturnStatement(firstSta)) &#123; //如果最后形成的是一个return表达式
                path.get(&#39;body&#39;).replaceWith(t.blockStatement([firstSta])); //就穿上blockstatement的外衣替换掉原先的函数体
            &#125; else &#123;
                //如果没有return，就穿上表达式的外衣替换掉原先的函数体
                path.get(&#39;body&#39;).replaceWith(t.blockStatement([t.expressionStatement(firstSta)]));
            &#125;
        &#125;
    &#125;);
&#125;
</code></pre>
<p><strong>效果</strong></p>
<pre><code class="javascript">Date.prototype.format = function (formatStr, str) &#123;
  return str = (str = (str = (str = formatStr, str).replace(/yyyy|YYYY/, this.getFullYear()), str).replace(/MM/, this.getMonth() + 1 &gt; 9 ? (this.getMonth() + 1).toString() : &#39;0&#39; + (this.getMonth() + 1)), str).replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#39;0&#39; + this.getDate()), str;
&#125;;
console.log(new Date().format(&#39;yyyy-MM-dd&#39;));
</code></pre>
<p>可以看出，<code>format</code>指向的函数原本5行的函数体被压缩成了一行，让人难以阅读。</p>
<h1 id="JS代码的还原"><a href="#JS代码的还原" class="headerlink" title="JS代码的还原"></a>JS代码的还原</h1><p>前面对代码进行了一系列的混淆操作，让逆向者难以阅读；对逆向者而言，也可以利用ast进行还原，虽不能达到完全还原的程度(标识符随机命名这个就没办法还原)，但也可大大提高代码阅读性。这里挑选上面提到的部分混淆方式，先形成一个混淆后js代码。</p>
<pre><code class="javascript">var OOOOOO=[&quot;MA==&quot;,&quot;Z2V0RGF0ZQ==&quot;,&quot;bG9n&quot;,&quot;eXl5eS1NTS1kZA==&quot;,&quot;RGF0ZQ==&quot;,&quot;cHJvdG90eXBl&quot;,&quot;Zm9ybWF0&quot;,&quot;cmVwbGFjZQ==&quot;,&quot;Z2V0RnVsbFllYXI=&quot;,&quot;Z2V0TW9udGg=&quot;,&quot;dG9TdHJpbmc=&quot;];!function(OOOOOO,OOOOOOo,OOOOOOO,OOOOOOo0,OOOOOOoo,OOOOOOoO,OOOOOOO0,OOOOOOOo,OOOOOOOO)&#123;OOOOOOO0=(OOOOOOoO=(OOOOOOoo=(OOOOOOo0=(OOOOOOO=function(OOOOOOo)&#123;while(--OOOOOOo)&#123;OOOOOO[&quot;\x70\x75\x73\x68&quot;](OOOOOO[&quot;\x73\x68\x69\x66\x74&quot;]())&#125;&#125;,function()&#123;for(OOOOOOOo=0,OOOOOOOO=[1];OOOOOOOo&lt;OOOOOOOO[&quot;\x6c\x65\x6e\x67\x74\x68&quot;];OOOOOOOo++)&#123;OOOOOOOO[&quot;\x70\x75\x73\x68&quot;](OOOOOOOo)&#125;&#125;),function()&#123;return&quot;debug review&quot;&#125;),/[\r\n]/),OOOOOOoO)[&quot;\x65\x78\x65\x63&quot;](OOOOOOoo[&quot;\x74\x6f\x53\x74\x72\x69\x6e\x67&quot;]()),OOOOOOO0?OOOOOOo0():OOOOOOO(OOOOOOo)&#125;(OOOOOO,16);window[atob(OOOOOO[784633^784633])][atob(OOOOOO[971616^971617])][atob(OOOOOO[935256^935258])]=function(OOOOOOo,OOOOOOO)&#123;return OOOOOOO=(OOOOOOO=(OOOOOOO=(OOOOOOO=OOOOOOo,OOOOOOO)[atob(OOOOOO[830960^830963])](/yyyy|YYYY/,this[atob(OOOOOO[993326^993322])]()),OOOOOOO)[atob(OOOOOO[460290^460289])](/MM/,this[atob(OOOOOO[219476^219473])]()+(675424^675425)&gt;(177916^177909)?(this[atob(OOOOOO[624670^624667])]()+(107576^107577))[atob(OOOOOO[155125^155123])]():atob(OOOOOO[330811^330812])+(this[atob(OOOOOO[278369^278372])]()+(631088^631089))),OOOOOOO)[atob(OOOOOO[873048^873051])](/dd|DD/,this[atob(OOOOOO[815701^815709])]()&gt;(402567^402574)?this[atob(OOOOOO[218780^218772])]()[atob(OOOOOO[674279^674273])]():atob(OOOOOO[433915^433916])+this[atob(OOOOOO[647323^647315])]()),OOOOOOO&#125;;console[atob(OOOOOO[813324^813317])](new window[atob(OOOOOO[944997^944997])]()[atob(OOOOOO[576679^576677])](atob(OOOOOO[927369^927363])));  
</code></pre>
<p>上面这个函数是可以被执行的<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/b8bab499bbec41b09e58ce2c2d0afc93.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="执行结果"></p>
<h2 id="分析混淆代码"><a href="#分析混淆代码" class="headerlink" title="分析混淆代码"></a>分析混淆代码</h2><p>压缩成一行的代码肯定是难以阅读的，格式化一下。</p>
<pre><code class="javascript">var OOOOOO = [&quot;MA==&quot;, &quot;Z2V0RGF0ZQ==&quot;, &quot;bG9n&quot;, &quot;eXl5eS1NTS1kZA==&quot;, &quot;RGF0ZQ==&quot;, &quot;cHJvdG90eXBl&quot;, &quot;Zm9ybWF0&quot;, &quot;cmVwbGFjZQ==&quot;, &quot;Z2V0RnVsbFllYXI=&quot;, &quot;Z2V0TW9udGg=&quot;, &quot;dG9TdHJpbmc=&quot;];
!function(OOOOOO, OOOOOOo, OOOOOOO, OOOOOOo0, OOOOOOoo, OOOOOOoO, OOOOOOO0, OOOOOOOo, OOOOOOOO) &#123;
    OOOOOOO0 = (OOOOOOoO = (OOOOOOoo = (OOOOOOo0 = (OOOOOOO = function(OOOOOOo) &#123;
        while (--OOOOOOo) &#123;
            OOOOOO[&quot;\x70\x75\x73\x68&quot;](OOOOOO[&quot;\x73\x68\x69\x66\x74&quot;]())
        &#125;
    &#125;
    ,
    function() &#123;
        for (OOOOOOOo = 0,
        OOOOOOOO = [1]; OOOOOOOo &lt; OOOOOOOO[&quot;\x6c\x65\x6e\x67\x74\x68&quot;]; OOOOOOOo++) &#123;
            OOOOOOOO[&quot;\x70\x75\x73\x68&quot;](OOOOOOOo)
        &#125;
    &#125;
    ),
    function() &#123;
        return &quot;debug review&quot;
    &#125;
    ),
    /[\r\n]/),
    OOOOOOoO)[&quot;\x65\x78\x65\x63&quot;](OOOOOOoo[&quot;\x74\x6f\x53\x74\x72\x69\x6e\x67&quot;]()),
    OOOOOOO0 ? OOOOOOo0() : OOOOOOO(OOOOOOo)
&#125;(OOOOOO, 16);
window[atob(OOOOOO[784633 ^ 784633])][atob(OOOOOO[971616 ^ 971617])][atob(OOOOOO[935256 ^ 935258])] = function(OOOOOOo, OOOOOOO) &#123;
    return OOOOOOO = (OOOOOOO = (OOOOOOO = (OOOOOOO = OOOOOOo,
    OOOOOOO)[atob(OOOOOO[830960 ^ 830963])](/yyyy|YYYY/, this[atob(OOOOOO[993326 ^ 993322])]()),
    OOOOOOO)[atob(OOOOOO[460290 ^ 460289])](/MM/, this[atob(OOOOOO[219476 ^ 219473])]() + (675424 ^ 675425) &gt; (177916 ^ 177909) ? (this[atob(OOOOOO[624670 ^ 624667])]() + (107576 ^ 107577))[atob(OOOOOO[155125 ^ 155123])]() : atob(OOOOOO[330811 ^ 330812]) + (this[atob(OOOOOO[278369 ^ 278372])]() + (631088 ^ 631089))),
    OOOOOOO)[atob(OOOOOO[873048 ^ 873051])](/dd|DD/, this[atob(OOOOOO[815701 ^ 815709])]() &gt; (402567 ^ 402574) ? this[atob(OOOOOO[218780 ^ 218772])]()[atob(OOOOOO[674279 ^ 674273])]() : atob(OOOOOO[433915 ^ 433916]) + this[atob(OOOOOO[647323 ^ 647315])]()),
    OOOOOOO
&#125;
;
console[atob(OOOOOO[813324 ^ 813317])](new window[atob(OOOOOO[944997 ^ 944997])]()[atob(OOOOOO[576679 ^ 576677])](atob(OOOOOO[927369 ^ 927363])));
</code></pre>
<p>此时运行：<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/f496a33cbff8406a906cf11e41057fd7.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="格式化后报内存溢出"></p>
<p>这说明代码中可能有格式化检测加内存爆破，仔细看代码结构，开头一个大数组，下面一个自执行函数，这是数组混淆和数组乱序的特征，而格式化检测很有可能在自执行函数里面。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/2c9a523b388a4301952c5d05a1272aa3.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="开头大数组与自执行函数"></p>
<p>还可以看到数值混淆和大量的同名函数调用，这是数值混淆和字符串加密的特征。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/8f1ed799edb642ff90e1a2836fbabe93.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="数值混淆和字符串加密"></p>
<p>还有一个很长的return语句，这是逗号表达式压缩的特征。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/c3bda51a5ebd4d7bb4421c8696d3fbce.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="很长的return语句"></p>
<p>初步分析下来，可以断定这个js用了字符串混淆，常量混淆和逗号表达式混淆，其中字符串混淆中掺杂了数组混淆、数组乱序、格式化检测等。下面针对这三种情况一一做还原操作。</p>
<h2 id="数值还原"><a href="#数值还原" class="headerlink" title="数值还原"></a>数值还原</h2><p>这是最容易的，主要思路是遍历所有的二项式表达式节点,当<code>left</code>和<code>right</code>都是<code>numericLiteral</code>时,调用<code>path.evaluate</code>计算出值后直接替换。</p>
<pre><code class="javascript">ReductionUtils.prototype.numericDecrypt = function () &#123;
    traverse(this.ast, &#123;
        BinaryExpression(path) &#123; //遍历所有的二项式表达式节点
            let left = path.node.left; //得到左边
            let right = path.node.right; //得到右边
            if (t.isNumericLiteral(left) &amp;&amp; t.isNumericLiteral(right)) &#123; //如果左右两边都是数值的话
                let &#123;confident, value&#125; = path.evaluate(); // 计算数表达式的值，这里用了对象解构写法
                confident &amp;&amp; path.replaceWith(t.valueToNode(value)) //confident 布尔值表示是否有更多的上下文影响到计算
            &#125;
        &#125;
    &#125;)
&#125;
</code></pre>
<p><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/96d279e1d0084c379d17f1097ea895dc.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="可以看出所有数值都得到了还原"></p>
<h2 id="字符串还原"><a href="#字符串还原" class="headerlink" title="字符串还原"></a>字符串还原</h2><p>思路是，先从待还原的js代码中提取出前两个节点(第一个是大数组,第二个自执行还原函数),转为字符串后用eval执行，这样大数组的真实顺序就保存在了内存中了；ast中遍历所有的标识符节点(经过上一步的处理，现在的主要矛盾是处理形如<code>atob(OOOOOO[9])</code>的代码),如果标识符是<code>atob</code>，并且其父节点是成员表达式的话，就把节点转字符串后用eval执行，由于内存中已经存在一个还原好的大数组，并且nodejs环境也自带<code>atob</code>，无需另外准备，执行后<code>atob(OOOOOO[9])</code>会直接得到最后的字符串结果。</p>
<pre><code class="javascript">ReductionUtils.prototype.stringDecrypt = function () &#123;
    let newAst = parser.parse(&#39;&#39;)
    newAst.program.body.push(this.ast.program.body[0]); //把大数组押入newAst
    newAst.program.body.push(this.ast.program.body[1]); //把数组还原函数押入newAst
    //把上面两部分代码转为字符串，由于存在格式化检测，需要指定选项来压缩代码
    let stringDecryptFunc = generator(newAst, &#123;compact: true&#125;).code;
    //将字符串形式的代码执行，这杨就可以在nodejs中运行解密函数了
    eval(stringDecryptFunc);
    //再次强调，由于原始代码中存在格式化检测和内存爆破的代码，所有上述代码在生成字符串代码时，需要指定选项，使用压缩后的代码来执行，否则会内存溢出
    //现在nodejs中已经有解密函数了，接下来可以去直接计算节点，并用结果替换它，这里我们用的解密函数中atob
    traverse(this.ast, &#123;
        //遍历所有表识符
        Identifier(path) &#123;
            //当变量名字与解密函数名相同时，判断其父路径是不是一个调用表达式如果是的话，将func字符串用eval执行再转ast节点替换，注意此时内存中的大数组的顺序已经被还原数组还原了，见上面的eval
            if (path.node.name === &#39;atob&#39;) &#123;
                path.parentPath.isCallExpression() &amp;&amp; path.parentPath.replaceWith(t.stringLiteral(eval(path.parentPath + &#39;&#39;)));
            &#125;
        &#125;
    &#125;)
    //删除最上面两层
    this.ast.program.body.shift()
    this.ast.program.body.shift()
&#125;  
</code></pre>
<p><strong>效果</strong></p>
<pre><code class="javascript">window[&quot;Date&quot;][&quot;prototype&quot;][&quot;format&quot;] = function (OOOOOOo, OOOOOOO) &#123;
  return OOOOOOO = (OOOOOOO = (OOOOOOO = (OOOOOOO = OOOOOOo, OOOOOOO)[&quot;replace&quot;](/yyyy|YYYY/, this[&quot;getFullYear&quot;]()), OOOOOOO)[&quot;replace&quot;](/MM/, this[&quot;getMonth&quot;]() + 1 &gt; 9 ? (this[&quot;getMonth&quot;]() + 1)[&quot;toString&quot;]() : &quot;0&quot; + (this[&quot;getMonth&quot;]() + 1)), OOOOOOO)[&quot;replace&quot;](/dd|DD/, this[&quot;getDate&quot;]() &gt; 9 ? this[&quot;getDate&quot;]()[&quot;toString&quot;]() : &quot;0&quot; + this[&quot;getDate&quot;]()), OOOOOOO;
&#125;;
console[&quot;log&quot;](new window[&quot;Date&quot;]()[&quot;format&quot;](&quot;yyyy-MM-dd&quot;));  
</code></pre>
<p>经过这一步，很多逻辑都显现了出来，可以明显看出这是在向<code>Date</code>的原型链上增加方法。</p>
<h2 id="逗号表达式还原"><a href="#逗号表达式还原" class="headerlink" title="逗号表达式还原"></a>逗号表达式还原</h2><p>思路是，遍历所有的逗号表达式，取出表达式列表的最后一个节点也就是最后一步运算,然后将列表中节点都插入到逗号表达式所在return语句的前面,最后将当前这个逗号表达式替换成最后一步运算。</p>
<pre><code class="javascript">ReductionUtils.prototype.sequenceReduction = function () &#123;
    traverse(this.ast, &#123;
        SequenceExpression: &#123; //遍历所有的逗号表达式节点
            exit(path) &#123; //在退出节点时进行操作
                let expressions = path.node.expressions; //expressions一个包含着逗号表达式子式的列表，顺序执行
                let finalExpression = expressions.pop(); //取出最后一步运算
                let statement = path.getStatementParent(); //取到逗号表达式外层的语句节点,这里其实就是return语句节点
                expressions.map(function (v) &#123;
                    statement.insertBefore(t.expressionStatement(v)) //在return前面挨个插入逗号表达式中表达式
                &#125;)
                path.replaceWith(finalExpression); //最后把这个逗号表达式直接替换成逗号表达式的最后一步
            &#125;
        &#125;
    &#125;)
&#125;  
</code></pre>
<p><strong>效果</strong></p>
<pre><code class="javascript">window[&quot;Date&quot;][&quot;prototype&quot;][&quot;format&quot;] = function (OOOOOOo, OOOOOOO) &#123;
  OOOOOOO = OOOOOOo;
  OOOOOOO = OOOOOOO[&quot;replace&quot;](/yyyy|YYYY/, this[&quot;getFullYear&quot;]());
  OOOOOOO = OOOOOOO[&quot;replace&quot;](/MM/, this[&quot;getMonth&quot;]() + 1 &gt; 9 ? (this[&quot;getMonth&quot;]() + 1)[&quot;toString&quot;]() : &quot;0&quot; + (this[&quot;getMonth&quot;]() + 1));
  OOOOOOO = OOOOOOO[&quot;replace&quot;](/dd|DD/, this[&quot;getDate&quot;]() &gt; 9 ? this[&quot;getDate&quot;]()[&quot;toString&quot;]() : &quot;0&quot; + this[&quot;getDate&quot;]());
  return OOOOOOO;
&#125;;
console[&quot;log&quot;](new window[&quot;Date&quot;]()[&quot;format&quot;](&quot;yyyy-MM-dd&quot;));  
</code></pre>
<p>至此，再看这段代码，逻辑就很清楚了，在<code>Date</code>的原型链上新增一个方法，传入一个参数，这个参数的<code>/yyyy|YYYY/</code>替换成<code>date.getFullYear()</code>的执行结果，也就是当前年份，月份部分替换逻辑是，如果<code>date.getMonth()</code>的月份+1 &gt; 9的话就返回<code>date.getMonth()</code>的月份+1，否则在最左边补一个0位(这是因为<code>date.getMonth()</code>取到的月份默认是从0开始的)，日期部分的逻辑和月份大同小异，最后函数调参打印输出结果。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/e81821f038bd47e28d580a4d6659c9e0.png?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg" alt="控制台测试还原结果"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>AST混淆与解混的过程就像是两个选手，一个出题，一个解题，题目千变万化，解法自然也无法做到一招吃遍天下，都是寻找破绽，见招拆招的过程，对于逆向者，熟悉常用的出题方式，总结一些定势是一方面，另外一方面更需要培养在一团乱麻中能让心保持巍然不动的定力，这才是应对无穷变化的终解。<br><img src="https://cthousand-pic-save.oss-cn-hangzhou.aliyuncs.com/images/20230607/36c71040882448f6b93cf317dc196228.jpg?x-oss-process=image/auto-orient,1/interlace,1/quality,q_100/format,jpg"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="用于做案例的JS代码"><a href="#用于做案例的JS代码" class="headerlink" title="用于做案例的JS代码"></a>用于做案例的JS代码</h2><pre><code class="javascript">Date.prototype.format = function (formatStr) &#123;
    var str = formatStr;
    str = str.replace(/yyyy|YYYY/, this.getFullYear());
    str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : &#39;0&#39; + (this.getMonth() + 1));
    str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#39;0&#39; + this.getDate()); //AsciiEncrypt
    return str;
&#125;
console.log(new Date().format(&#39;yyyy-MM-dd&#39;));  
</code></pre>
<h2 id="用于还原数组乱序的代码"><a href="#用于还原数组乱序的代码" class="headerlink" title="用于还原数组乱序的代码"></a>用于还原数组乱序的代码</h2><pre><code class="javascript">!(function (myArr, num) &#123;
    var outOrder = function (num) &#123;
        while (--num) &#123; //循环次数递减
            myArr.push(myArr.shift()); //数组开头取出末尾插入
        &#125;
    &#125;;
    //内存爆破
    var memBreak = function () &#123;
        for (var i = 0, j = [1]; i &lt; j.length; i++) &#123;
            j.push(i) //每次都push,逻辑上i永远都小于j.length
        &#125;
    &#125;

    var formatFuc = function () &#123;
        return &#39;debug review&#39;
    &#125;
    var formatReg = /[\r\n]/; //查找换行符或回车符

    var match = formatReg.exec(formatFuc.toString()); //格式化检测
    if (match) &#123;
        memBreak(); //如果检测出来格式化就进入内存爆破的函数
    &#125; else &#123;
        outOrder(num); //否则执行正确的逻辑分支
    &#125;
&#125;)(arr, 0x10) //0x10表示移动16位，用16进制表示增加迷惑性  
</code></pre>
<h2 id="用于混淆JS的代码"><a href="#用于混淆JS的代码" class="headerlink" title="用于混淆JS的代码"></a>用于混淆JS的代码</h2><pre><code class="javascript">const parser = require(&#39;@babel/parser&#39;) //解析
const traverse = require(&#39;@babel/traverse&#39;).default //遍历
const t = require(&#39;@babel/types&#39;) //类型判定与生成
const generator = require(&#39;@babel/generator&#39;).default //ast转code
const fs = require(&#39;fs&#39;) //文件读写

//把混淆方案的相关实现封装成类
function ConfoundUtils(ast, encryptFunc) &#123;
    this.ast = ast;
    this.bigArr = [];
    //接收传进来的函数，用于字符串加密
    this.encryptFunc = encryptFunc;
&#125;

//改变对象属性访问方式，例如console.log改为console[&#39;log&#39;]
ConfoundUtils.prototype.changeAccessMode = function () &#123;
    traverse(this.ast, &#123;
        MemberExpression(path) &#123; //遍历所有的成员表达式
            if (t.isIdentifier(path.node.property)) &#123; //如果节点的属性是标识符的话
                let name = path.node.property.name; //获取标识符的名称
                path.node.property = t.stringLiteral(name); //用字符串字面量替换原先的标识符
                path.node.computed = true; //对象读写属性设置为true
            &#125;
        &#125;
    &#125;)
&#125;

//标准内置对象的处理
ConfoundUtils.prototype.changeBuiltinObjects = function () &#123;
    traverse(this.ast, &#123;
        Identifier(path) &#123;
            let name = path.node.name; //获取标识符的名称
            //如果名称与这些内置对象同名
            if (&#39;eval|parseInt|encodeURIComponent|Object|Function|Boolean|Number|Math|Date|String|RegExp|Array&#39;.indexOf(name) !== -1) &#123;
                //用window[name]成员表达式替换之
                path.replaceWith(t.MemberExpression(t.identifier(&#39;window&#39;), t.stringLiteral(name), true));
            &#125;
        &#125;
    &#125;)
&#125;

//数值常量加密
ConfoundUtils.prototype.numericEncrypt = function () &#123;
    traverse(this.ast, &#123;
        NumericLiteral(path) &#123;
            let value = path.node.value; //获取数值常量的值
            //生成100000~999999的随机10进制的字符串
            let key = parseInt(Math.random() * (999999 - 100000) + 100000, 10);
            let cipherNum = value ^ key;//真实数值异或这个随机值得到一个加密值,异或是两边二进制对位同为0,异为1
            //那么加密异或key也一定可以还原为真实值
            path.replaceWith(t.binaryExpression(&#39;^&#39;, t.numericLiteral(cipherNum), t.numericLiteral(key)));
            path.skip(); //这是因为替换后防止继续深度遍历numericLiteral,形成死循环
        &#125;
    &#125;)
&#125;

//字符串加密与数组混淆
ConfoundUtils.prototype.arrayConfound = function () &#123;
    let bigArr = [];
    let encryptFunc = this.encryptFunc;
    traverse(this.ast, &#123;
        StringLiteral(path) &#123;
            let cipherText = encryptFunc(path.node.value); //获取字符串值
            let bigArrIndex = bigArr.indexOf(cipherText); //在大数组中查找是否有这个值,如有返回索引
            let index = bigArrIndex; // 索引赋值给index
            if (bigArrIndex === -1) &#123; //若索引不存在
                let length = bigArr.push(cipherText); //将字符串推入大数组,并返回数组长度,push是推入最后
                index = length - 1 //index为大数组中最后一位的索引
            &#125;
            //构造函数调用表达式(加密),内部成员表达式(数组混淆),从数组中用索引取值
            let encStr = t.callExpression(t.identifier(&#39;atob&#39;),
                [t.memberExpression(t.identifier(&#39;arr&#39;), t.numericLiteral(index), true)]);
            path.replaceWith(encStr);
        &#125;
    &#125;);
    bigArr = bigArr.map(function (v) &#123;
        return t.StringLiteral(v); //大数组内的成员转ast代码
    &#125;);
    this.bigArr = bigArr;
&#125;

//数组乱序
ConfoundUtils.prototype.arrayShuffle = function () &#123;
    !function (myArr, num) &#123;
        var cthousand = function (num) &#123;
            while (--num) &#123;
                myArr.unshift(myArr.pop());
            &#125;
        &#125;
        cthousand(num)
    &#125;(this.bigArr, 0x10) //默认16次
&#125;

//二项式转函数花指令
ConfoundUtils.prototype.binaryToFunc = function () &#123;
    traverse(this.ast, &#123;
        BinaryExpression(path) &#123; //遍历所有的二项式表达式节点
            let operator = path.node.operator;//获取节点中的操作符
            let left = path.node.left; //获取左边内容
            let right = path.node.right; //获取右边内容
            let a = t.identifier(&#39;a&#39;); //新建标示符a
            let b = t.identifier(&#39;b&#39;); //新建标示符b
            //生成唯一性的随机标示符作为函数名称，由于后期标识符会统一修改，这个仅做中转
            let funcNameIdentifier = path.scope.generateUidIdentifier(&#39;xxx&#39;);
            // 定义一个函数声明语句
            let func = t.functionDeclaration(
                funcNameIdentifier,
                [a, b],
                t.blockStatement([t.returnStatement(
                    t.binaryExpression(operator, a, b)
                )]));
            // 寻找当前最近的函数体表达式节点，这里用findParent
            let BlockStatement = path.findParent(
                function (p) &#123;
                    return p.isBlockStatement()
                &#125;
            );
            // 开头插入花指令函数
            BlockStatement.node.body.unshift(func);
            // 节点替换成函数调用表达式
            path.replaceWith(t.callExpression(funcNameIdentifier, [left, right]));
        &#125;
    &#125;)
&#125;

//十六进制字符串
ConfoundUtils.prototype.stringToHex = function () &#123;
    function hexEnc(code) &#123;
        for (var hexStr = &#39;&#39;, i = 0, s; i &lt; code.length; i++) &#123;
            s = code.charCodeAt(i).toString(16);
            hexStr += &#39;\\x&#39; + s;
        &#125;
        return hexStr
    &#125;

    traverse(this.ast, &#123;
        MemberExpression(path) &#123;
            if (t.isIdentifier(path.node.property)) &#123;
                let name = path.node.property.name;
                path.node.property = t.stringLiteral(hexEnc(name));
                path.node.computed = true;
            &#125;
        &#125;
    &#125;)
&#125;
//标识符混淆
ConfoundUtils.prototype.renameIdentifier = function () &#123;
    //标识符混淆之前先转成代码再解析，确保新生成的一些节点被解析到，因为type生成的节点并不会自动携带path，所以无法被遍历到
    let code = generator(this.ast).code;
    let newAst = parser.parse(code);

    //生成标识符
    function generatorIdentifier(decNum) &#123;
        let arr = [&#39;0&#39;, &#39;o&#39;, &#39;O&#39;]; //这3个字符长得比较像，用来替换3进制中012
        let retval = [];
        //十进制转三进制的算法
        while (decNum &gt; 0) &#123;
            retval.push(decNum % 3);
            decNum = parseInt(decNum / 3);
        &#125;
        //除余法需要先事先翻转一下
        let Identifier = retval.reverse().map(function (v) &#123;
            return arr[v]
        &#125;).join(&#39;&#39;)
        //不足6位就补，开头是0也补(数字不可做标识符的开头)
        Identifier.length &lt; 6 ? (Identifier = (&#39;OOOOOO&#39; + Identifier).substring(-6)) : Identifier[0] === &#39;0&#39; &amp;&amp; (Identifier = &#39;O&#39; + Identifier);
        return Identifier
    &#125;

    function renameOwnBinding(path) &#123;
        let OwnBindingObj = &#123;&#125;, globalBindingObj = &#123;&#125;, i = 0; //从十进制的0开始
        path.traverse(&#123;
            Identifier(p) &#123;
                let name = p.node.name; //取出标识符的名称
                let binding = p.scope.getOwnBinding(name); //拿到这个标识符在当前作用域的节点绑定，就是说在当前作用域中定义的
                binding &amp;&amp; generator(binding.scope.block).code === path + &#39;&#39; ?
                    (OwnBindingObj[name] = binding) : (globalBindingObj[name] = 1); //将局部标识符和全局标识符区分开
            &#125;
        &#125;)
        for (let oldName in OwnBindingObj) &#123; //对于每一个局部作用域中的成员
            do &#123;
                var newName = generatorIdentifier(i++);
            &#125; while (globalBindingObj[newName]); //为了不与全局变量重名，虽然这种可能性比较小
            OwnBindingObj[oldName].scope.rename(oldName, newName); //利用scope.rename对所有引用的变量批量修改
        &#125;
    &#125;

    traverse(newAst, &#123;
        &#39;Program|FunctionExpression|FunctionDeclaration&#39;(path) &#123;
            renameOwnBinding(path); //无论是全局还是匿名函数内还是函数声明内都查找标识符并改名
        &#125;
    &#125;)
    this.ast = newAst; //把新ast重新赋值给this.ast
&#125;

//指定代码行base64加密
ConfoundUtils.prototype.appointedCodeLineEncrypt = function () &#123;
    traverse(this.ast, &#123;
        FunctionExpression(path) &#123;
            let blockStatement = path.node.body;
            let Statements = blockStatement.body.map(function (v) &#123;
                if (t.isReturnStatement(v)) return v;
                if (!(v.trailingComments &amp;&amp; v.trailingComments[0].value === &#39;Base64Encrypt&#39;)) return v;
                delete v.trailingComments;
                let code = generator(v).code();
                let cipherText = btoa(code);
                let decryptFunc = t.callExpression(t.identifier(&#39;atob&#39;),
                    [t.stringLiteral(cipherText)]);
                return t.expressionStatement(
                    t.callExpression(t.identifier(&#39;eval&#39;), [decryptFunc])
                )
            &#125;)
            path.get(&#39;body&#39;).replaceInline(t.blockStatement(Statements))
        &#125;
    &#125;)
&#125;
//指定代码行ascii码混淆
ConfoundUtils.prototype.appointedCodeLineAscii = function () &#123;
    traverse(this.ast, &#123;
        FunctionExpression(path) &#123; //遍历所有函数表达式
            let blockStatement = path.node.body; //提取出函数体
            let Statements = blockStatement.body.map(function (v) &#123; //遍历函数体中每一行
                if (t.isReturnStatement(v)) return v; //如果是返回语句则不修改
                //如果没有注释部分且注释部分非ASCIIEncrypt则不修改
                if (!(v.trailingComments &amp;&amp; v.trailingComments[0].value === &#39;AsciiEncrypt&#39;)) return v;
                //删除注释部分
                delete v.trailingComments;
                let code = generator(v).code; //将函数转化为code
                let codeAscii = [].map.call(code, function (v) &#123;
                    return t.numericLiteral(v.charCodeAt(0)); //把字符串中每个字符串转化成ascii码形式变成一个列表
                &#125;);
                // 定义一个成员表达式，对象是String,成员是fromCharCode
                let decryptFunctionName = t.memberExpression(t.identifier(&#39;String&#39;), t.identifier(&#39;fromCharCode&#39;));
                //定义一个函数调用，函数是上面那个成员表达式，参数是ascii化的代码行
                let decryptFunc = t.callExpression(decryptFunctionName, codeAscii)
                //返回一个表达式，内嵌函数调用，调用方是eval，参数是fromCharCode解ascii码后的字符串,eval执行的代码会在eval里运行
                return t.expressionStatement(t.callExpression(t.identifier(&#39;eval&#39;), [decryptFunc]))
            &#125;);
            //将当前func path的函数体替换掉
            path.get(&#39;body&#39;).replaceWith(t.blockStatement(Statements));

        &#125;
    &#125;)
&#125;

// 构建数组声明语句，加入到ast最前面
ConfoundUtils.prototype.unshiftArrayDeclaration = function () &#123;
    this.bigArr = t.variableDeclarator(t.identifier(&#39;arr&#39;), t.arrayExpression(this.bigArr)); //构建大数组变量
    this.bigArr = t.variableDeclaration(&#39;var&#39;, [this.bigArr]); //构建大数组变量声明语句
    this.ast.program.body.unshift(this.bigArr); //在ast的最上层插入大数组
&#125;

// 拼接两个ast的body部分
ConfoundUtils.prototype.astConcatUnshift = function (ast) &#123;
    this.ast.program.body.unshift(ast)
&#125;
ConfoundUtils.prototype.getAst = function () &#123;
    return this.ast
&#125;

// 控制流平坦化
ConfoundUtils.prototype.controlFlowFlat = function () &#123;
    traverse(this.ast, &#123;
        //遍历所有的函数表达式
        FunctionExpression(path) &#123;
            //取出函数体
            let blockStatement = path.node.body;
            let Statements = blockStatement.body.map(function (v, i) &#123;
                //将函数体列表的顺序和语句存储起来
                return &#123;index: i, value: v&#125;
            &#125;);
            //得到代码行的长度
            let i = Statements.length;
            //对代码行列表进行乱序处理，虽然乱序处理了，但真实序号依然与代码绑定在一起
            while (i) &#123;
                let j = Math.floor(Math.random() * i--);
                [Statements[j], Statements[i]] = [Statements[i], Statements[j]]
            &#125;
            //定义一个分发器
            let dispenserArr = [];
            //定义一个存在case块的列表
            let cases = [];
            //对代码行列表进行映射，篡改一些对象的引用关系
            Statements.map(function (v, i) &#123;
                //分发器记录真实顺序
                dispenserArr[v.index] = i;
                //构建swtich的case语句，包括一个判断条件，执行流程和一个continue语句
                let switchCase = t.switchCase(t.numericLiteral(i), [v.value, t.continueStatement()]);
                cases.push(switchCase)
            &#125;);
            //分发器数组用｜连接成字符串
            let dispenserStr = dispenserArr.join(&#39;|&#39;);
            //构建不重名的标识符代表分发器
            let array = path.scope.generateUidIdentifier(&#39;array&#39;);
            //构建不重名的标识符代表起始索引
            let index = path.scope.generateUidIdentifier(&#39;index&#39;);
            //构建成员表达式，obj是分发器字符串，成员是split
            let callee = t.memberExpression(t.stringLiteral(dispenserStr), t.identifier(&#39;split&#39;));
            //构建函数调用，传入参数&#39;|&#39;
            let arrayInit = t.callExpression(callee, [t.stringLiteral(&#39;|&#39;)]);
            //构建变量声明器，变量明是分发器标识符，初始化是上面那个
            let varArray = t.variableDeclarator(array, arrayInit);
            //构建初始索引，从0开始
            let varIndex = t.variableDeclarator(index, t.numericLiteral(0))
            //用let将上面2为构成完整的变量声明语句
            let dispenser = t.variableDeclaration(&#39;let&#39;, [varArray, varIndex]);
            //构建自增表达式
            let updExp = t.updateExpression(&#39;++&#39;, index);
            //构建成员表达式
            let memExp = t.memberExpression(array, updExp, true);
            //构建单项式表达式，这里用为了将字符串强转成字符串类型，因为case中用的是===全等，并不会自动转化类型
            let discriminent = t.unaryExpression(&#39;+&#39;, memExp);
            //将switch表达式和case块合成完整的switch语句块
            let switchSta = t.switchStatement(discriminent, cases);
            let unaExp = t.unaryExpression(&#39;!&#39;, t.arrayExpression());
            //!![]意思就是true，之所以不直接用当然是为了混淆视听
            unaExp = t.unaryExpression(&#39;!&#39;, unaExp);
            //构建while循环语句，需要循环条件和循环体，循环体需要一个switch块和一个break语句，因为需要保证到最后没有匹配时默认退出循环
            let whileSta = t.whileStatement(unaExp, t.blockStatement([switchSta, t.breakStatement()]));
            //将函数体节点替换成由分发器和while循环构成的函数体语句
            path.get(&#39;body&#39;).replaceWith(t.blockStatement([dispenser, whileSta]));
        &#125;
    &#125;)
&#125;

//逗号表达式混淆
ConfoundUtils.prototype.toSequenceConfuse = function () &#123;
    //逗号表达式混淆
    traverse(this.ast, &#123;
        FunctionExpression(path) &#123;
            let blockStatement = path.node.body; //取出函数体
            let blockStatementLength = blockStatement.body.length; //得到函数体代码行数
            if (blockStatementLength &lt; 2) return; //如果小于2直接返回不处理
            path.traverse(&#123;
                VariableDeclaration(p) &#123; //遍历函数下的所有变量声明语句
                    let declarations = p.node.declarations; //得到声明体
                    let statements = [] //定义一个列表用于存放函数赋值表达式
                    declarations.map(function (v) &#123;
                        path.node.params.push(v.id); //对变量声明语句处理，把标识符提到参数里面
                        //如果有初始化赋值，就把赋予语句放到之前定义好的列表里面
                        v.init &amp;&amp; statements.push(t.assignmentExpression(&#39;=&#39;, v.id, v.init));
                    &#125;)
                    //把所有变量声明语句变成赋值语句
                    p.replaceInline(statements);
                &#125;
            &#125;)
            //处理赋值语句、返回语句和函数调用语句
            let firstSta = blockStatement.body[0], i = 1; //从第一行开始
            let secondSta; //定义第二行
            while (i &lt; blockStatementLength) &#123; //如果索引小于函数体的行数
                let tempSta = blockStatement.body[i++]; //i++先赋值再自增，暂存下一行
                t.isExpressionStatement(tempSta) ? //是否是表达式语句
                    secondSta = tempSta.expression : secondSta = tempSta; //是把里面的expreesion赋值给第二行，否则把本身赋值给第二行
                //处理返回语句
                if (t.isReturnStatement(secondSta)) &#123; //第二行是否为return 语句
                    firstSta = t.returnStatement( //如果是就用return 包裹第一行和第二行return语句的参数部分
                        t.toSequenceExpression([firstSta, secondSta.argument])
                    )
                &#125; else if (t.isAssignmentExpression(secondSta)) &#123; //如果第二行是赋值语句
                    if (t.isCallExpression(secondSta.right)) &#123; //是否赋值语句的右边是函数调用语句
                        let callee = secondSta.right.callee; //如果是就把函数调用obj提出来
                        callee.object = t.toSequenceExpression([firstSta, callee.object]); //和第一行语句组成逗号表达式
                        firstSta = secondSta; //赋值给第一行
                    &#125; else &#123;
                        secondSta.right = t.toSequenceExpression([firstSta, secondSta.right]); //否则拼接第一行和第二行的右边赋值部分给到第二行的右边
                        firstSta = secondSta; //再把第二行赋值给第一行
                    &#125;
                &#125; else &#123;
                    firstSta = t.toSequenceExpression([firstSta, secondSta]); //如果既不是返回语句也非赋值语句，就简单的拼成逗号表达式
                &#125;
            &#125;
            if (t.isReturnStatement(firstSta)) &#123; //如果最后形成的是一个return表达式
                path.get(&#39;body&#39;).replaceWith(t.blockStatement([firstSta])); //就穿上blockstatement的外衣替换掉原先的函数体
            &#125; else &#123;
                //如果没有return，就穿上表达式的外衣替换掉原先的函数体
                path.get(&#39;body&#39;).replaceWith(t.blockStatement([t.expressionStatement(firstSta)]));
            &#125;
        &#125;
    &#125;);
&#125;


function main() &#123;
    //读取要混淆的代码
    const jscode = fs.readFileSync(&#39;./demo.js&#39;, &#123;
        encoding: &#39;utf-8&#39;
    &#125;)
    // 读取还原数组乱序的代码
    const jscodeFront = fs.readFileSync(&#39;./demoFront.js&#39;, &#123;
        encoding: &#39;utf-8&#39;
    &#125;)
    //把要混淆的代码解析成ast
    let ast = parser.parse(jscode);
    //把还原数组乱序的代码解析成astFront
    let astFront = parser.parse(jscodeFront);
    //初始化类，传递自定义的加密函数进去
    let confoundAst = new ConfoundUtils(ast, btoa);
    let confoundAstFront = new ConfoundUtils(astFront);
    // 改变对象属性访问方式
    confoundAst.changeAccessMode();
    // 标准内置对象的处理
    confoundAst.changeBuiltinObjects();

    // 字符串加密与数组混淆
    confoundAst.arrayConfound();
    // 数组乱序
    confoundAst.arrayShuffle()

    // 标识符重命名
    // confoundAst.renameIdentifier()
    // //指定代码行的base64混淆，需要放到标识符混淆之后
    // confoundAst.appointedCodeLineEncrypt();
    // confoundAst.appointedCodeLineAscii();
    // 数值常量混淆
    confoundAst.numericEncrypt();
    // //控制流平坦化
    // confoundAst.controlFlowFlat();
    //
    //还原数组顺序代码，改变对象属性访问方式，对其中的字符串进行十六进制编码
    confoundAstFront.stringToHex();
    astFront = confoundAstFront.getAst();
    //先把还原数组顺序的代码，加入到被混淆代码的ast中
    confoundAst.astConcatUnshift(astFront.program.body[0]);
    //再生成数组声明语句，并加入到被混淆代码的最开始处
    confoundAst.unshiftArrayDeclaration()
    // confoundAst.renameIdentifier() //可以在每次新的标识符生成后用一次

    //二项式转函数花指令
    // confoundAst.binaryToFunc()
    // 逗号表达式混淆
    confoundAst.toSequenceConfuse() //一般不与花指令+控制流平坦化混用

    confoundAst.renameIdentifier() //可以在每次新的标识符生成后用一次

    ast = confoundAst.getAst()
    //ast转为代码
    let code = generator(ast, &#123;
        comments: false,
        minified: true
    &#125;).code;
    //混淆的代码中，如果有十六进制字符串加密，ast转成代码后会有多余的转义字符，需要替换掉
    code = code.replace(/\\\\x/g, &#39;\\x&#39;)
    //将代码保存到文件中
    fs.writeFile(&#39;./demoNew.js&#39;, code, (err) =&gt; &#123;
    &#125;)
&#125;

main()
</code></pre>
<h2 id="用于解混JS的代码"><a href="#用于解混JS的代码" class="headerlink" title="用于解混JS的代码"></a>用于解混JS的代码</h2><pre><code class="javascript">const parser = require(&#39;@babel/parser&#39;) //解析
const traverse = require(&#39;@babel/traverse&#39;).default //遍历
const t = require(&#39;@babel/types&#39;) //类型判定与生成
const generator = require(&#39;@babel/generator&#39;).default //ast转code
const fs = require(&#39;fs&#39;) //文件读写


function ReductionUtils(ast) &#123;
    this.ast = ast;
&#125;

//数值还原
ReductionUtils.prototype.numericDecrypt = function () &#123;
    traverse(this.ast, &#123;
        BinaryExpression(path) &#123; //遍历所有的二项式表达式节点
            let left = path.node.left; //得到左边
            let right = path.node.right; //得到右边
            if (t.isNumericLiteral(left) &amp;&amp; t.isNumericLiteral(right)) &#123; //如果左右两边都是数值的话
                let &#123;confident, value&#125; = path.evaluate(); // 计算数表达式的值，这里用了对象解构写法
                confident &amp;&amp; path.replaceWith(t.valueToNode(value)) //confident 布尔值表示是否有更多的上下文影响到计算
            &#125;
        &#125;
    &#125;)
&#125;
ReductionUtils.prototype.getAst = function () &#123;
    return this.ast
&#125;
//我们都知道解密函数是atob,下面进入字符串还原
ReductionUtils.prototype.stringDecrypt = function () &#123;
    let newAst = parser.parse(&#39;&#39;)
    newAst.program.body.push(this.ast.program.body[0]); //把大数组押入newAst
    newAst.program.body.push(this.ast.program.body[1]); //把数组还原函数押入newAst
    //把上面两部分代码转为字符串，由于存在格式化检测，需要指定选项来压缩代码
    let stringDecryptFunc = generator(newAst, &#123;compact: true&#125;).code;
    //将字符串形式的代码执行，这杨就可以在nodejs中运行解密函数了
    eval(stringDecryptFunc);
    //再次强调，由于原始代码中存在格式化检测和内存爆破的代码，所有上述代码在生成字符串代码时，需要指定选项，使用压缩后的代码来执行，否则会内存溢出
    //现在nodejs中已经有解密函数了，接下来可以去直接计算节点，并用结果替换它，这里我们用的解密函数中atob
    traverse(this.ast, &#123;
        //遍历所有表识符
        Identifier(path) &#123;
            //当变量名字与解密函数名相同时，判断其父路径是不是一个调用表达式如果是的话，将func字符串用eval执行再转ast节点替换，注意此时内存中的大数组的顺序已经被还原数组还原了，见上面的eval
            if (path.node.name === &#39;atob&#39;) &#123;
                path.parentPath.isCallExpression() &amp;&amp; path.parentPath.replaceWith(t.stringLiteral(eval(path.parentPath + &#39;&#39;)));
            &#125;
        &#125;
    &#125;)
    //删除最上面两层
    this.ast.program.body.shift()
    this.ast.program.body.shift()
&#125;

//逗号表达式的还原
//逗号表达式的还原相对于混淆的实现来说，要容易的多
ReductionUtils.prototype.sequenceReduction = function () &#123;
    traverse(this.ast, &#123;
        SequenceExpression: &#123; //遍历所有的逗号表达式节点
            exit(path) &#123; //在退出节点时进行操作
                let expressions = path.node.expressions; //expressions一个包含着逗号表达式子式的列表，顺序执行
                let finalExpression = expressions.pop(); //取出最后一步运算
                let statement = path.getStatementParent(); //取到逗号表达式外层的语句节点,这里其实就是return语句节点
                expressions.map(function (v) &#123;
                    statement.insertBefore(t.expressionStatement(v)) //在return前面挨个插入逗号表达式中表达式
                &#125;)
                path.replaceWith(finalExpression); //最后把这个逗号表达式直接替换成逗号表达式的最后一步
            &#125;
        &#125;
    &#125;)
&#125;

function main() &#123;
    //读取要还原的代码
    const jsCode = fs.readFileSync(&#39;./demoNew.js&#39;, &#123;
        encoding: &#39;utf-8&#39;
    &#125;)
    //把要还原的代码解析成ast
    let ast = parser.parse(jsCode);
    //初始化类，传递自定义的加密函数进去
    let ReductionAst = new ReductionUtils(ast);
    //数值常量还原
    ReductionAst.numericDecrypt()
    //字符串解密
    ReductionAst.stringDecrypt()
    //逗号表达式还原
    ReductionAst.sequenceReduction()

    ast = ReductionAst.getAst()
    //ast转为代码
    let code = generator(ast, &#123;
        comments: false,
        // jsescOption: &#123;minimal: true&#125;,
        // minified: true
    &#125;).code;
    ast = parser.parse(code)
    code = generator(ast).code;
    //将代码保存到文件中
    fs.writeFile(&#39;./demoReduction.js&#39;, code, (err) =&gt; &#123;
    &#125;)
&#125;

main()
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达，如有问题请邮件至2454612285@qq.com。 </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021-2025 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
